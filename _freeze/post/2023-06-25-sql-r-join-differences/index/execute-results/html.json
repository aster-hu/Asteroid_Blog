{
  "hash": "73f89187b381e046db8d480691c3092d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"The differences of left join in SQL and R\"\ncategories: [R, dplyr, SQL, data, 2023]\ndescription: How the two languages handle NA in joins differently\ndate: 2023-06-26\nimage: sql_r.png\n---\n\n\nRecently, I encountered a situation where I needed to translate an Access SQL query to R, and I noticed the contrasting behaviors of these two languages when it comes to handling NA/NULL values in left joins.\n\n## The impact of NA/NULL values on joins\n\nWhen performing a join operation between two tables, it is essential to consider the presence of NA/NULL values. Let's take a left join as an example, where all records from the left table are retained and are attempted to be matched with corresponding rows in the right table. However, the presence of NA/NULL values raises questions about whether they should be matched with any corresponding values in the right table. As a result, this can lead to unexpected results due to the uncertainty inherent in the logic of the chosen tool.\n\n## SQL's approach to handle NULL in joins\n\nLet's look at a simple example by creating two tables named `fname` and `lname`.\n\n<details>\n\n<summary>Click to expand the code</summary>\n\n``` sql\nCREATE TABLE\n  fname (id int, firstname varchar(50));\n\nINSERT INTO fname\nVALUES\n  (1, 'Ada'),\n  (2, 'Bob'),\n  (NULL, 'Unknown');\n\nCREATE TABLE\n  lname (id int, lastname varchar(50));\n\nINSERT INTO lname\nVALUES\n  (1, 'Smith'),\n  (NULL, 'To be decided');\n```\n\n</details>\n\n```         \n# fname\n    id  firstname\n1    1        Ada\n2    2        Bob\n3 NULL    Unknown\n\n# lname\n    id      lastname\n1    1         Smith\n2 NULL To be decided\n```\n\nIn the `fname` table, the 3rd observation contains a `NULL` value in `id`, while still having a placeholder value of \"Unknown\" in the `firstname` column. The same situation also occurs in the `lname` table, where the 2nd observation has a NULL value in `id` and it's being labeled as \"To be decided\" in the `lastname` column.\n\nIt may seem unusual, but this type of data is not uncommom in business settings, where it often occurs due to low-quality data or when businesses require a placeholder for empty observations that can be analyzed later.\n\nIf we apply a `LEFT JOIN` in SQL, the code would be:\n\n``` sql\nSELECT *\nFROM fname\n  LEFT JOIN lname ON fname.id = lname.id;\n```\n\nAnd this is the outcome we will get.\n\n``` r\n    id firstname   id lastname\n1    1       Ada    1    Smith\n2    2       Bob NULL     NULL\n3 NULL   Unknown NULL     NULL\n```\n\nAs we can see, the placeholder value \"To be decided\" in the `lname` table has disappeared. This occurs because in SQL, NULL values in tables or views being joined never match each other[^1], resulting in SQL not returning a matched result.\n\n[^1]: *SyBooks Online*. (2011). Infocenter.sybase.com. [https://infocenter.sybase.com/help/index.jsp?topic=/com.sybase.infocenter.dc32300.1570/html/sqlug/X78356.htm](https://infocenter.sybase.com/help/index.jsp?topic=/com.sybase.infocenter.dc32300.1570/html/sqlug/X78356.htm)\n\nThe question is, is this the expected outcome? Based on above result, it's impossible to tell whether a match couldn't be found, or if it represent a NULL value. Besides, what if we want to match these two NULL values and have \"To be decided\" correspond with \"Unknown\"? These questions remain until we have a clear mind of how we wish to handle NULL values.\n\n## How R handles NA in joins\n\nMore precisely, we are referring to `dplyr::left_join`. Let's create the same tables in R and perform a left join.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\nfname <- tibble(\n  id = c(1:2, NA_character_),\n  firstname = c(\"Ada\", \"Bob\", \"Unknown\")\n)\n\nlname <- tibble(\n  id = c(1, NA_character_),\n  lastname = c(\"Smith\", \"To be decided\")\n)\n\nleft_join(fname, lname, by = \"id\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n  id    firstname lastname     \n  <chr> <chr>     <chr>        \n1 1     Ada       Smith        \n2 2     Bob       <NA>         \n3 <NA>  Unknown   To be decided\n```\n\n\n:::\n:::\n\n\n::: callout-note\nIf you see a warning message saying \"Each row in `x` is expected to match at most 1 row in `y`\", this is a result of the multiple matches warning in dplyr 1.1.0. Tidyverse has modified the behaviour of multiple matches warning since dplyr 1.1.1, significantly reducing the number of warnings. For more information, please refer to the [release note of dplyr 1.1.1](https://www.tidyverse.org/blog/2023/03/dplyr-1-1-1/)\n:::\n\nFrom the above table, it actually returned a matched result \"To be decided\" for the NA value! This is because in R, by default two NA or NaN values are considered as equal, like `%in%`, `match()`, and `merge()`.[^2]\n\n[^2]: *Mutating joins --- mutate-joins*. (n.d.). Dplyr.tidyverse.org. [https://dplyr.tidyverse.org/reference/mutate-joins.html](https://dplyr.tidyverse.org/reference/mutate-joins.html)\n\nThe good news is that we can modify this behaviour in R by utilizing the `na_matches` argument. When we set `na_matches = \"never\"`, it will behave the same way as in SQL.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nleft_join(fname, lname, by = \"id\", na_matches = \"never\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n  id    firstname lastname\n  <chr> <chr>     <chr>   \n1 1     Ada       Smith   \n2 2     Bob       <NA>    \n3 <NA>  Unknown   <NA>    \n```\n\n\n:::\n:::\n\n\n### What if there are multiple NAs?\n\nGenerally speaking, having multiple NAs in key variable in joins is not considered a best practice and it is usually preferable to omit them. However, we may come across such situations from time to time.\n\nAssuming we have another NA in the `lname` table:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlname <- data.frame(id = c(1, NA_character_, NA_character_),\n                     lastname = c(\"Smith\", \"To be decided\", \"Pending\"))\nlname\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    id      lastname\n1    1         Smith\n2 <NA> To be decided\n3 <NA>       Pending\n```\n\n\n:::\n:::\n\n\nWhat would happen if we join the two tables again?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nleft_join(fname, lname, by = \"id\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 3\n  id    firstname lastname     \n  <chr> <chr>     <chr>        \n1 1     Ada       Smith        \n2 2     Bob       <NA>         \n3 <NA>  Unknown   To be decided\n4 <NA>  Unknown   Pending      \n```\n\n\n:::\n:::\n\n\nSince R treats two NAs as equal, similar to handling duplicates in key variables, it will return all the information from the right table due to multiple matches.\n\n## Conclusion and takeaway\n\nIn SQL, NULL values in tables being joined are not considered as equal. When both table have NA/NULL value in the key variable, SQL treats them as unmatched, which differs from the default behaviour of `dplyr::left_join`, where NA is treated as a a match. When working with both SQL and R for data analysis, it is crucial to be mindful of the divergent handling of NULL values and adjust the join behaviour accordingly in order to deliver consistent outcomes.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}