{
  "hash": "0ef2cd1fefe49ef60357ba60c0d0f058",
  "result": {
    "markdown": "---\ntitle: \"Replace missing value from other columns using coalesce join in dplyr\"\ncategories: [R, handling-na, dplyr, coalesce, function-programming, 2023]\ndescription: A simple solution to handle NA value.\ndate: 2023-03-30\nformat: \n  html:\n    df-print: tibble\ndraft: true\n---\n\n\n![](dplyr.png)\n\n## Coalesce function in dplyr\n\nWhen cleaning and aggregating data using dplyr package in R, [`coalesce()`](https://dplyr.tidyverse.org/reference/coalesce.html) is extremely handy to replace the NA value with values from other columns.\n\n### A simple example\n\nHow does `coalesce()` work originally? Below is a simple example to showcase one of the common usage.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get some simple data\ndf1 <- data.frame(id  = c(1:3),\n                  col = c('A', NA, NA))\n\ndf2 <- data.frame(id = c(1:3),\n                  col = c(NA, 'B', NA))\n\ndf1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n     id col  \n  <int> <chr>\n1     1 A    \n2     2 <NA> \n3     3 <NA> \n```\n:::\n\n```{.r .cell-code}\ndf2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n     id col  \n  <int> <chr>\n1     1 <NA> \n2     2 B    \n3     3 <NA> \n```\n:::\n:::\n\n\nThe desired result is to combine these two tables and replace all NA values when the key `id` matches, like this:\n\n```         \n  id  col\n1  1    A\n2  2    B\n3  3 <NA>\n```\n\nBelow is how we usually do it using `coalesce()`, by joining the tables first and then coalescing from the identical vectors `col` from two data frames.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\n# The usual dplyr way to coalesce\nfull_join(df1, df2, by = \"id\") %>% \n  mutate(\n    col = coalesce(col.x, col.y),\n    .keep = \"unused\" # Remove temporary columns ended with .x and .y\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n     id col  \n  <int> <chr>\n1     1 A    \n2     2 B    \n3     3 <NA> \n```\n:::\n:::\n\n\n### What's the pain point of `coalesce()`?\n\nLooks great so far, right? But remember, this is the most simple case. In the real world, it's common to have more than one variable that need to be coalesced. Applying the same method multiple times can quickly become a chore.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# A more complicated example\n# Both colA and colB need to be coalesced\ndf1 <- data.frame(id  = c(1:3),\n                  colA = c('A', NA, NA),\n                  colB = c('X', NA, NA))\n\ndf2 <- data.frame(id = c(1:3),\n                  colA = c(NA, 'B', NA),\n                  colB = c(NA, 'Y', NA))\n\ndf1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 3\n     id colA  colB \n  <int> <chr> <chr>\n1     1 A     X    \n2     2 <NA>  <NA> \n3     3 <NA>  <NA> \n```\n:::\n\n```{.r .cell-code}\ndf2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 3\n     id colA  colB \n  <int> <chr> <chr>\n1     1 <NA>  <NA> \n2     2 B     Y    \n3     3 <NA>  <NA> \n```\n:::\n:::\n\n\nIf we use the same way as the simple example, it looks like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# The usual dplyr way to coalesce\nfull_join(df1, df2, by = \"id\") %>% \n  mutate(\n    # Coalesce becomes more redundant when multiple columns are involved\n    colA = coalesce(colA.x, colA.y),\n    colB = coalesce(colB.x, colB.y),\n    .keep = \"unused\" # Remove temporary columns ended with .x and .y\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 3\n     id colA  colB \n  <int> <chr> <chr>\n1     1 A     X    \n2     2 B     Y    \n3     3 <NA>  <NA> \n```\n:::\n:::\n\n\nWe get the desired result, but the code looks quite cumbersome. Image if we have more variables like `colC`, `colD`, ..., etc. You get the idea.\n\nUnfortunately, it's usually a wide data set with numerous columns whenever I need to use `coalesce()`. Not only that, there are other scenarios that `coalesce` cannot handle.\n\nBy default, it always override values from `.x` over `.y` and cannot do the other way due to its origin from SQL COALESCE. This could be a problem if different non-missing value exists in both columns. For example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# A more complicated example\n# Both colA and colB need to be coalesced\n# For colB, df1 has 'X1' while df2 has `X2`\ndf1 <- data.frame(id  = c(1:3),\n                  colA = c('A', NA, NA),\n                  colB = c('X1', NA, NA))\n\ndf2 <- data.frame(id = c(1:3),\n                  colA = c(NA, 'B', NA),\n                  colB = c('X2', 'Y', NA))\n\ndf1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 3\n     id colA  colB \n  <int> <chr> <chr>\n1     1 A     X1   \n2     2 <NA>  <NA> \n3     3 <NA>  <NA> \n```\n:::\n\n```{.r .cell-code}\ndf2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 3\n     id colA  colB \n  <int> <chr> <chr>\n1     1 <NA>  X2   \n2     2 B     Y    \n3     3 <NA>  <NA> \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# The usual dplyr way to coalesce\nfull_join(df1, df2, by = \"id\") %>% \n  mutate(\n    # Coalesce becomes more redundant when multiple columns are involved\n    colA = coalesce(colA.x, colA.y),\n    colB = coalesce(colB.x, colB.y),\n    .keep = \"unused\" # Remove temporary columns ended with .x and .y\n  ) #  And it always takes the left value over the right\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 3\n     id colA  colB \n  <int> <chr> <chr>\n1     1 A     X1   \n2     2 B     Y    \n3     3 <NA>  <NA> \n```\n:::\n:::\n\n\nAs the above result shows, `coalesce()` takes the left value `X1` in `df1`, but what if I want `X2` from `df2` to be shown in the result? In reality, the default option might not meet the expectation.\n\n### A simple solution by using the coalesce join function\n\nTo simplify the workflow of `coalesce()`, I wrote a `coalesce_join()` function with my partner Rick to resolve all the pain points we mentioned. Here is the code and it can also be found on [gist](https://gist.github.com/xiesixia/d10befd1ce6f0186a2f7cdc6537f34c1).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrequire(dplyr)\nrequire(stringr)\n\ncoalesce_join <- function(x, \n                          y, \n                          by = NULL, \n                          keep = c(\"left\", \"right\"), # \"left\" means keep value from left table if values exist in both tables.\n                          suffix = c(\".x\", \".y\"), # Same as the suffix argument in dplyr joins. \n                          join = c(\"full_join\",\"left_join\", \"right_join\", \"inner_join\") # Choose a join type from the list. The default is full_join.\n                          ) { \n  keep = match.arg(keep) \n  join = match.arg(join) \n  join = match.fun(join) # Confirm the join argument is in the list and match the string to the function\n  \n  # Depends on the keep argument, overwrite the duplicate value\n  # If keep = \"left\", the value from the left table will be kept, vice versa.\n  if (keep == \"left\") suffix_ = suffix else suffix_ = rev(suffix)\n  \n  join(x, y, by = by, suffix = suffix) %>% \n    mutate(\n      across( # Apply the coalesce function to all overlapped columns\n        ends_with(suffix_[1]), # Select columns ended with .x if keep = \"left\"; or .y if keep = \"right\"\n        ~coalesce(.,\n                  get(str_replace(cur_column(), suffix_[1], suffix_[2])) # Replace .x in var.x with .y to generate var.y, if keep = \"left\"; or vice versa.\n        ),\n        .names = \"{str_remove(.col, suffix_[1])}\" # Remove the suffix from the combined columns\n      ),\n      .keep = \"unused\") # Remove the temporary columns ended with suffix\n  }\n```\n:::\n\n\nLet's try applying it to the same data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoalesce_join(df1, df2, by = \"id\") \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 3\n     id colA  colB \n  <int> <chr> <chr>\n1     1 A     X1   \n2     2 B     Y    \n3     3 <NA>  <NA> \n```\n:::\n:::\n\n\nSo it worked and we get the same result, with few more advantages:\n\n1.  Eliminate the chores of writing the chain(s) of `coalesce(.x, .y)`\n\n2.  Simplify the code by combining `coalesce()` and dplyr joins. The `join` argument is where we select the join type, from `full_join`, `left_join`, `right_join`, `inner_join`. `anti_join` is not in the list, obviously, because `coalesce()` will not be applicable.\n\n3.  It can be customized to take value from right table, if different non-missing values exists. In the example above, if we want to take the right value `X2`, we can simply do so by setting the argument `keep = \"right\"`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Take the value from right table when non-missing value exists in both\ncoalesce_join(df1, df2, by = \"id\", keep = \"right\") \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 3\n     id colA  colB \n  <int> <chr> <chr>\n1     1 A     X2   \n2     2 B     Y    \n3     3 <NA>  <NA> \n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}